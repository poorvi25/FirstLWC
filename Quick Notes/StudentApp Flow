

# ⭐ **Student App**

## **1. Project Structure**

* **studentApp** → Parent LWC
* **studentForm** → Child component (Create Student)
* **studentList** → Child component (List + Delete + Refresh)

Parent wraps both children and handles communication.

---

## **2. Salesforce Backend Setup**

### ✔ Created Custom Object: **Student__c**

Fields:

* Name (Standard)
* Email__c (Email)
* Class__c (Text)
* Phone__c (Phone)

This object stores all student records.

---

## **3. Create Student Feature (studentForm)**

### ✔ HTML:

* Three input fields: Name, Email, Class
* Button → “Create Student”

### ✔ JS Logic:

* Collects input values
* Builds a student object
* Calls Apex method `createStudent`
* Shows success toast
* Clears form
* Fires a custom event:

```js
this.dispatchEvent(new CustomEvent('studentcreated'));
```

Purpose: notify parent that a new student is added.

---

## **4. Apex – Create Student**

In **StudentController.cls**:

```apex
@AuraEnabled
public static Student__c createStudent(Student__c student) {
    insert student;
    return student;
}
```

Inserts new record into Student__c.

---

## **5. List Students Feature (studentList)**

### ✔ HTML:

* Lightning Datatable showing:

  * Name
  * Email
  * Class
  * Phone

### ✔ JS Logic:

* Uses `@wire(getAllStudents)` to fetch list
* Stores wire result for refreshing
* Contains public method:

```js
@api refreshList() {
    return refreshApex(this.wiredResult);
}
```

This re-runs the wire method and updates the table immediately.

---

## **6. Apex – Get All Students**

```apex
@AuraEnabled(cacheable=true)
public static List<Student__c> getAllStudents() {
    return [SELECT Id, Name, Email__c, Class__c, Phone__c FROM Student__c];
}
```

---

## **7. Parent Component Communication (studentApp)**

### ✔ Receives event from form:

```html
<c-student-form onstudentcreated={handleStudentCreated}></c-student-form>
```

### ✔ Handles event:

```js
handleStudentCreated() {
    const listCmp = this.template.querySelector('c-student-list');
    listCmp.refreshList();
}
```

Purpose:
When a student is created → refresh the list automatically.

---

## **8. Delete Student Feature**

Added a Delete button inside datatable:

```js
{
    type: 'button',
    typeAttributes: {
        label: 'Delete',
        name: 'delete',
        variant: 'destructive'
    }
}
```

### ✔ Row Action Handler:

```js
handleRowAction(event) {
    if (event.detail.action.name === 'delete') {
        this.deleteStudent(event.detail.row.Id);
    }
}
```

### ✔ Apex Method – Delete Student:

```apex
@AuraEnabled
public static void deleteStudent(Id studentId) {
    delete [SELECT Id FROM Student__c WHERE Id = :studentId];
}
```

### ✔ Refresh After Delete:

```js
this.refreshList();
```

---

# ⭐ **End Result So Far**

You have a fully working **CRUD (Create + Read + Delete)** Student App:

* Create Student
* Auto-refresh list after creation
* Show student table
* Delete student with toast notification
* Parent-child communication
* Apex integration
* Real-time UI updates

Everything is now working like a real Salesforce production app.

-------------------------------
EDIT flow:
User clicks Edit →
    Show modal →
        Pre-fill old values →
            User edits →
                Call Apex update →
                    Close modal →
                        Refresh datatable →
                            Updated values visible immediately


The Student App has -
CRUD operation representation 
-----------------------------
Search Flow:

User types in search box →
    LWC captures text →
        LWC looks at all students →
            LWC filters the list →
                Datatable updates instantly →
                    No Apex calls needed


⭐ SEARCH FEATURE — SIMPLE EXPLANATION

Right now, your studentList component loads all students using @wire:

wiredStudents(result) {
    this.wiredResult = result;
    this.students = result.data;
}


So this.students already contains every student record.

Now the user wants to SEARCH for something, for example:

“A”

“Poorvi”

“gmail”

“Class A”

So we need a way to filter the list.

That is what your search feature does.

⭐ PART 1 — User Types Something

You added a search input:

<lightning-input 
    placeholder="Search by name, email or class"
    value={searchKey}
    onchange={handleSearchChange}>
</lightning-input>


Meaning:

Whenever user types something → handleSearchChange() runs

The text they typed goes into searchKey

⭐ PART 2 — Store the text
handleSearchChange(event) {
    this.searchKey = event.target.value;
    this.filterRecords();   // filter list
}


Meaning:

Store the typed text in searchKey

Then call filterRecords() to actually filter the list

⭐ PART 3 — Filter Logic (THE MAIN PART)
filterRecords() {
    if (!this.searchKey) {
        this.students = this.wiredResult.data; // show full list
        return;
    }

    const lower = this.searchKey.toLowerCase();

    this.students = this.wiredResult.data.filter(student =>
        student.Name?.toLowerCase().includes(lower) ||
        student.Email__c?.toLowerCase().includes(lower) ||
        student.Class__c?.toLowerCase().includes(lower)
    );
}

What this means:
✔ 1. If search is EMPTY → show ALL records

(This gives default behavior.)

✔ 2. Convert the search text to lowercase

(for case-insensitive matching)

✔ 3. Loop through each student record

and check:

Does the Name contain the search text?

OR does the Email contain the search text?

OR does the Class contain the search text?

If YES → keep that student
If NO → hide that student

✔ 4. Update the datatable by updating this.students
⭐ NO APEX CALL IS NEEDED

Why?

Because you already have ALL records from @wire.
So LWC can filter the list instantly without querying Salesforce again.

This makes search:

Fast

Smooth

Real-time

Zero API cost

Zero lag